// Generated from C:\Users\imenrayan\Desktop\EMFeRTTC18-master\jastadd-mquat-base\build\tmp\preprocessParser\MquatParser.all
package de.tudresden.inf.st.mquat.jastadd.parser;
import de.tudresden.inf.st.mquat.jastadd.model.*;
import de.tudresden.inf.st.mquat.parser.MquatParserHelper;
import java.util.Map;
import java.util.HashMap; 
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "MquatParser.beaver".
 */
public class MquatParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short RB_CURLY = 1;
		static public final short NAME = 2;
		static public final short META = 3;
		static public final short REQUIRING = 4;
		static public final short PROVIDING = 5;
		static public final short REQUIRES = 6;
		static public final short PROPERTY = 7;
		static public final short RESOURCE = 8;
		static public final short RB_ROUND = 9;
		static public final short INTEGER = 10;
		static public final short REAL = 11;
		static public final short LB_ROUND = 12;
		static public final short COMPONENT = 13;
		static public final short CONTAINER = 14;
		static public final short MINIMIZE = 15;
		static public final short REQUEST = 16;
		static public final short MULT = 17;
		static public final short DIV = 18;
		static public final short PLUS = 19;
		static public final short MINUS = 20;
		static public final short POW = 21;
		static public final short USING = 22;
		static public final short LB_CURLY = 23;
		static public final short EQ = 24;
		static public final short CONTRACT = 25;
		static public final short OFTYPE = 26;
		static public final short LT = 27;
		static public final short LE = 28;
		static public final short NE = 29;
		static public final short GE = 30;
		static public final short GT = 31;
		static public final short WITH = 32;
		static public final short TYPE = 33;
		static public final short COMMA = 34;
		static public final short RIGHT_ARROW = 35;
		static public final short COLON = 36;
		static public final short UNIT = 37;
		static public final short DOT = 38;
		static public final short SOLUTION = 39;

		static public final String[] NAMES = {
			"EOF",
			"RB_CURLY",
			"NAME",
			"META",
			"REQUIRING",
			"PROVIDING",
			"REQUIRES",
			"PROPERTY",
			"RESOURCE",
			"RB_ROUND",
			"INTEGER",
			"REAL",
			"LB_ROUND",
			"COMPONENT",
			"CONTAINER",
			"MINIMIZE",
			"REQUEST",
			"MULT",
			"DIV",
			"PLUS",
			"MINUS",
			"POW",
			"USING",
			"LB_CURLY",
			"EQ",
			"CONTRACT",
			"OFTYPE",
			"LT",
			"LE",
			"NE",
			"GE",
			"GT",
			"WITH",
			"TYPE",
			"COMMA",
			"RIGHT_ARROW",
			"COLON",
			"UNIT",
			"DOT",
			"SOLUTION",
		};
	}
	static public class AltGoals {
		static public final short solution = 40;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obc0cyLsCQnt$dd7Axr6s4UokfREMlMztkBHBZbZQH6XB6ZDqmPXZhQ99z6TbI4L52jaZ" +
		"x8aKYj6dHHYWDiiIOa30pvftl#vxtdF#vjplwPExp#Rs$vtsszvntEUVyhnHzOJwjBZh2F8" +
		"9iPwzPr0YqyhsFpJhWH3bDeZtKB42CQnSaFkoNwcRN3ixRp4mYPiQYOxGdRMspGBrqj7gef" +
		"pedFknxgGtjxhe$RpEVcBU14$s6iJzHfNwjqtI6pjBBUYdnOP$7s9#e5cEdDlEFlEW2r$vE" +
		"v#kFkaWNgwdvJyR$PLxKnF4CDJOpOj4k6Vztkj5y5ulgcA$XhsFHjRhUzHEvHxibFkGhyhw" +
		"AHRkQRV2sM7G3UTiI7pASl6sfV4lUjx6edjaARur5Dv6tDV4XGv6jgNn3tZUngCXiWRV4eb" +
		"l9svBuaCSq8F4XcrZtJTfNb#lFPXDQNQqr7#bTgplvo8fcQYg#wUYRj5gJr5nlgzWifx$SH" +
		"Qo5bzCYh0kw1ckWMQRsO98EmB8CxK0DKaWCkhb3zSthLbIcSlfMVysAIX9TU#eK$OBPiVee" +
		"fA6wghVwwWJrrnvw4Xc997lhg5Jhbch7QMzDGCPgl1bhnkfn9F7zAjNwfTf9gNQgcQvzpFH" +
		"OKkjlpJJp1N2IMaytKytdm4bgFTDCqK5cIYofzMmpMGURoR6arlFC9FDtu2Ir$jvCL5ipCP" +
		"RK#WSpGUtCX5XIwuNcMVDlu2Ir$icCLpCpFfRKUebvnhm0dB1E8rIe1rYdWIgWNG06gQNPQ" +
		"3Pg8Tf0yxvvNwCvZPirN$lfNdYGBZCRp0RjRpQRzM2pUTwiLocjbRdOLeBrvargpJ9pRQk9" +
		"PYNrMc5RQ5Re4FrIvpZlOlrLZvX5s1QwqKjT#x1PIDzUyK8TwUtppGZpBww1AZwgbNdEF8T" +
		"bBRPtiQtLyx0TRRucgfCELnSyX#ajDT1kxDbrwcZ#2RlHpGzwsclVQvpvtWhtyAXvL16rsf" +
		"lFQECQ2LVjbQf2vJkCQGzs5DDXXtK6gBjvYpRfJT8LzipgIjSEqr$S2Nx9pUezkbd3q0Vh3" +
		"jsbkysJvZvpd$SCiHRhDK#eJnfVIWMUhnhguX$NyPhhFSETPOuPWynnCjkUHJFRYdqkw0LD" +
		"voIES6TnchECmcBvH7Y6g$kWdiCxIazGrwxfoJfNLvarUiYiraYurAmsgypzo1fujSjPYdM" +
		"LqrxHAlHNkChNpSkqxrYOUMOUxTqyXnv6vfaXQ7SYTo73p32rK6iBCzgCrjNcH$EZcxjUEj" +
		"OyX7o8V83y3Hb5zGV1ICJgiv07p0FiidWFNQFhp7lcNTt2kA#PTtGRVATvsepJxUOfJNRhU" +
		"nzuqxpez35wJC$gKQSlrrEqKpHRp#X5SwzPgZdc3RtAA4kq1CyYBIEcL6lOkOlDgtf3Ayry" +
		"lQSLsDOhKCXUhANQseMpMOTpcdEsUYfIVPwDkxElz#0vkPUALSBpiP4QyyHhedtKLCruIfT" +
		"mNdCwW2Tl2$A2j5O5rGfvajfQyhPyhHpL6j8sojGAg9Laj#2jNAYMrC$fO7SMMsUoZsEE6x" +
		"gdQpOxFtP3DtRUrqPjCzaTtDWdLXixp6JNgPBTdUlFPsSZJt2H0S$qn59I9R9DQhTNLvZsx" +
		"8eNLgjPSrxbpymBVsPUoK$cYSXiNex8GzMHfv$TEVkh7RQATEV4kydEVJ6U8kQx2xP3U7VQ" +
		"goicr#wcmCN5unMxt4Pu0jxP4PwUsAp$M3pzk3hhFvaLYLVXADxMiJ$kx#$yjb$frYNUnJa" +
		"ahB9xof7sI7vlrQG5lCbwy2GvsbNgZVnqV3QpUpg7MQjsmbgtHclXJbGegT4Qx8IriaPhuz" +
		"Hgr#bupdy1MdytxmNCUEXMlmWjSbeTvozcBUiv$x7EsYVrsnqG#egDKslawktdsfnVHzj6V" +
		"lHurIjuGWJfgeUkxOobo5rn4LSSsulTFHOxU#Xh1ivkTsO5MZk#K2kSfnZVhhpBw#9fnPwr" +
		"STtWXcZT$EW1uoPQPw#5Bl8WK4Piw6iaNBKNkhsxevWoyF$NQUFEGfkqL#3FRDoMUGxICrX" +
		"6H2CTmTlvI3ThoTh4bZ8tbuL494#QCdV6a$X2dg$P#6o5m9t5MBSvnp3hoLayn5boM2mNmh" +
		"6b7BOdjGTrxPeMigRskLCEshkTK#3sOUXtLrmtz5e7vx68jJeEGTfMrHBO$PSWvrexTtRqh" +
		"2VUks6DoFazLEBkFzxX5Ux#GsyfyRsGFH#oXnfxFVQ5heQr7GYNP78AN8MSl#wuthw8zLf$" +
		"Gzx58VjMsd2zx5zegHoq1CF1KF0oc2e5nV1wy0EwVKz$1hQWTmGNWc7a4ny#mIEcFYW3PsF" +
		"l2Yubjf3#rUXtmjU26y1Du1PmA$QUy21u9dmDpBZHTTJZMe9vS1Tu6VW0jE3tly5s2VfQ#2" +
		"JuE#9lH1y1kBxmGN05602e5zq6Fynr4AFxqUy1Iz5FWBaMFG8$HfrpuAU0lRzdmJIm47G31" +
		"rAdAMnZda5lWBuSVI9wC$IFq6UW7uN#EVhpw7tb7hj10VqNuATXxYUO3Y#0NuANm8jXUtzh" +
		"o3cT1EOiN4b$8xmEjlMO$s0RR6qK3UruTO7rbU2h97Sm#jxmxN1pcFaEMUDe2BW0tQxBbM0" +
		"ayLQVXErmnck1FXa#5vu2kFU8TG#$XkqzsNMnQykuqImGWI9Wxx4Hc0ri3UunpC4l0kOncW" +
		"lQCXRh5N7V4VCMjeRdWmdWLVgTOUOv6WEOawW3O3sYiO1vYXOHmzw9ve370UiHFGd6SRtKZ" +
		"fYxQ3nZD26k1$efS2$uLBW$V0PixulrZknyiuQHdTjEy2hwfy6huJDXzbFq9dYBFlCLCVUH" +
		"tOjsNLu1xm3MARmSjkjn3FmQs03O2z75s1WtOeq2zd$4EaOV0lPYz37u5Am0xBLeO7pkWZ1" +
		"c7MJPsvRdTGrDz8pVVcFLytffTN$LMFNEv9rNpSS#3xxqlZhLSpbcFzHGhu6FRvAtXLTv7k" +
		"FpDlh#kTldXrrzdPQ#Jd$Ff$xlUuWkz35dPExbeen#MKOVK3KtkDhphPw7Utx8ypW$HclVd" +
		"#PvhkT5dbTxVj$pvchtDT$pwvuN#xhjF9$lx$lwV8v6UvwLgLDAuyUAXdZRYen$dUTFFN#L" +
		"zqNrVRszChQc6VrWdvFBsuAZC$wYp3XdPM9wPU$LnuwedWUNUDxRipslVdx3hLNprSt7TCh" +
		"KuVaSLTOmrbJFpQlPR$Arlgrg3$jwxkVZPdgUv#FjtnNyGWX0o9TcRRwFGe$0eIlV7wsnRu" +
		"$08#Bj6JZqnDwFVZzoEbAZhtlZ1dm7H23#tMJVweVYooD8SHZvdR35g0K2ZuZVhW5VDc46G" +
		"OgsV1#rvKtVmNstXEwBodw$n8ZS5suxOjeHqmL$ZC31Vg4UphZjqSlTTrB0TrXjliGAGMs#" +
		"emg0$U#J$OrLQwTm1EFa4QGu4L#b#xLQu7xvT4S$3diVXv1VK7A$edexXFno3q38Tvf0m6y" +
		"70VjRmYBazxH0m5lS8jGf$mKXEONA");
 // Generated from C:\Users\imenrayan\Desktop\EMFeRTTC18-master\jastadd-mquat-base\build\tmp\preprocessParser\MquatParser.all
private MquatParserHelper mph = new MquatParserHelper();
  private static <T extends ASTNode<?>> void insertZero(List<T> listNode, T child) {
    listNode.insertChild(child, 0);
  }


  /**
   * Post processing step after parsing a model, to resolve all references within the model.
   * @throws java.util.NoSuchElementException if a reference can not be resolved
   */
  public void resolveReferences() {
    mph.resolveReferences();
  }


  /**
   * Post processing step after parsing a solution, to resolve all references.
   * @param model the model to resolve the references
   * @throws RuntimeException if assignments are malformed
   * @throws java.util.NoSuchElementException if a reference can not be resolved
   */
  public void resolveSolutionReferencesWith(Root model) {
    mph.resolveSolutionReferencesWith(model);
  }

	public MquatParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 2: // request = REQUEST.REQUEST component_ref.c LB_CURLY.LB_CURLY request_body.b RB_CURLY.RB_CURLY
			{
					final Symbol REQUEST = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final ComponentRef c = (ComponentRef) _symbol_c.value;
					final Symbol LB_CURLY = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Request b = (Request) _symbol_b.value;
					final Symbol RB_CURLY = _symbols[offset + 5];
					 b.setTarget(c); return b;
			}
			case 3: // request_body = meta_parameter_assignment.m request_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MetaParameterAssignment m = (MetaParameterAssignment) _symbol_m.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Request b = (Request) _symbol_b.value;
					 insertZero(b.getMetaParameterAssignmentList(), m); return b;
			}
			case 4: // request_body = clause.c request_body.b
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Clause c = (Clause) _symbol_c.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Request b = (Request) _symbol_b.value;
					 insertZero(b.getConstraintList(), c); return b;
			}
			case 5: // request_body = meta_parameter_assignment.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MetaParameterAssignment m = (MetaParameterAssignment) _symbol_m.value;
					 return new Request(new List<>(m), null, new List<>());
			}
			case 6: // request_body = clause.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Clause c = (Clause) _symbol_c.value;
					 return new Request(new List<>(), null, new List<>(c));
			}
			case 7: // meta_parameter_assignment = META.META meta_parameter_ref.n EQ.EQ literal_expression.e
			{
					final Symbol META = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final MetaParameterRef n = (MetaParameterRef) _symbol_n.value;
					final Symbol EQ = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final LiteralExpression e = (LiteralExpression) _symbol_e.value;
					 return new MetaParameterAssignment(n, e);
			}
			case 8: // expression = LB_ROUND.LB_ROUND expression.a MULT.MULT expression.b RB_ROUND.RB_ROUND
			{
					final Symbol LB_ROUND = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol MULT = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expression b = (Expression) _symbol_b.value;
					final Symbol RB_ROUND = _symbols[offset + 5];
					 return new MultExpression(a, b);
			}
			case 9: // expression = LB_ROUND.LB_ROUND expression.a DIV.DIV expression.b RB_ROUND.RB_ROUND
			{
					final Symbol LB_ROUND = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol DIV = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expression b = (Expression) _symbol_b.value;
					final Symbol RB_ROUND = _symbols[offset + 5];
					 return new DivExpression(a, b);
			}
			case 10: // expression = LB_ROUND.LB_ROUND expression.a PLUS.PLUS expression.b RB_ROUND.RB_ROUND
			{
					final Symbol LB_ROUND = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol PLUS = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expression b = (Expression) _symbol_b.value;
					final Symbol RB_ROUND = _symbols[offset + 5];
					 return new AddExpression(a, b);
			}
			case 11: // expression = LB_ROUND.LB_ROUND expression.a MINUS.MINUS expression.b RB_ROUND.RB_ROUND
			{
					final Symbol LB_ROUND = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol MINUS = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expression b = (Expression) _symbol_b.value;
					final Symbol RB_ROUND = _symbols[offset + 5];
					 return new SubExpression(a, b);
			}
			case 12: // expression = LB_ROUND.LB_ROUND expression.a POW.POW expression.b RB_ROUND.RB_ROUND
			{
					final Symbol LB_ROUND = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol POW = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expression b = (Expression) _symbol_b.value;
					final Symbol RB_ROUND = _symbols[offset + 5];
					 return new PowerExpression(a, b);
			}
			case 13: // expression = literal_expression.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final LiteralExpression l = (LiteralExpression) _symbol_l.value;
					 return l;
			}
			case 14: // expression = designator.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final Designator d = (Designator) _symbol_d.value;
					 return d;
			}
			case 15: // expression = LB_ROUND.LB_ROUND expression.e RB_ROUND.RB_ROUND
			{
					final Symbol LB_ROUND = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol RB_ROUND = _symbols[offset + 3];
					 return new ParenthesizedExpression(e);
			}
			case 16: // literal_expression = INTEGER.n
			{
					final Symbol n = _symbols[offset + 1];
					 return new LiteralExpression(Integer.parseInt(((String)n.value)));
			}
			case 17: // literal_expression = REAL.n
			{
					final Symbol n = _symbols[offset + 1];
					 return new LiteralExpression(Double.parseDouble(((String)n.value)));
			}
			case 18: // objective = MINIMIZE.MINIMIZE NAME.n LB_ROUND.LB_ROUND property_ref.p RB_ROUND.RB_ROUND
			{
					final Symbol MINIMIZE = _symbols[offset + 1];
					final Symbol n = _symbols[offset + 2];
					final Symbol LB_ROUND = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final PropertyRef p = (PropertyRef) _symbol_p.value;
					final Symbol RB_ROUND = _symbols[offset + 5];
					 if (((String)n.value).equals("sum")) {
        return new Objective(p, PropertyAggregation.SUM);
      } else if (((String)n.value).equals("maximum")) {
        return new Objective(p, PropertyAggregation.MAX);
      }
			}
			case 19: // goal = hardware_model.h software_model.s objective.o
			{
					final Symbol _symbol_h = _symbols[offset + 1];
					final HardwareModel h = (HardwareModel) _symbol_h.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final SoftwareModel s = (SoftwareModel) _symbol_s.value;
					final Symbol _symbol_o = _symbols[offset + 3];
					final Objective o = (Objective) _symbol_o.value;
					 return new Root(h,s,new List(),o);
			}
			case 20: // goal = hardware_model.h software_model.s request_list.r objective.o
			{
					final Symbol _symbol_h = _symbols[offset + 1];
					final HardwareModel h = (HardwareModel) _symbol_h.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final SoftwareModel s = (SoftwareModel) _symbol_s.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final List r = (List) _symbol_r.value;
					final Symbol _symbol_o = _symbols[offset + 4];
					final Objective o = (Objective) _symbol_o.value;
					 return new Root(h,s,r,o);
			}
			case 21: // meta_parameter = META.META name.n
			{
					final Symbol META = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Name n = (Name) _symbol_n.value;
					 MetaParameter m = new MetaParameter(n);
      mph.metaParameterMap.put(n.getName(), m);
      return m;
			}
			case 22: // meta_parameter_ref = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					 MetaParameterRef ref = new MetaParameterRef(n, null);
      mph.metaParameterRefList.add(ref);
      return ref;
			}
			case 23: // name = NAME.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new Name(((String)i.value));
			}
			case 24: // qualified_name = name.n DOT.DOT qualified_name.q
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_q = _symbols[offset + 3];
					final QualifiedName q = (QualifiedName) _symbol_q.value;
					 insertZero(q.getNameList(), n); return q;
			}
			case 25: // qualified_name = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					 List<Name> names = new List<>(); names.add(n); return new QualifiedName(names);
			}
			case 26: // property = PROPERTY.PROPERTY name.n UNIT.u
			{
					final Symbol PROPERTY = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Name n = (Name) _symbol_n.value;
					final Symbol u = _symbols[offset + 3];
					 Property p = new Property(n, ((String)u.value).substring(1, ((String)u.value).length() - 1));
      mph.propertyMap.put(n.getName(), p);
      return p;
			}
			case 27: // property_ref = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					 PropertyRef ref = new PropertyRef(n, null); mph.propertyRefList.add(ref); return ref;
			}
			case 28: // software_model = meta_parameter.a software_model.m
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final MetaParameter a = (MetaParameter) _symbol_a.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final SoftwareModel m = (SoftwareModel) _symbol_m.value;
					 insertZero(m.getMetaParameterList(), a); return m;
			}
			case 29: // software_model = component.c software_model.m
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Component c = (Component) _symbol_c.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final SoftwareModel m = (SoftwareModel) _symbol_m.value;
					 insertZero(m.getComponentList(), c); return m;
			}
			case 30: // software_model = property.p software_model.m
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Property p = (Property) _symbol_p.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final SoftwareModel m = (SoftwareModel) _symbol_m.value;
					 insertZero(m.getPropertyList(), p); return m;
			}
			case 31: // software_model = meta_parameter.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MetaParameter m = (MetaParameter) _symbol_m.value;
					 return new SoftwareModel(new List<>(m), new List<>(), new List<>());
			}
			case 32: // software_model = component.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Component c = (Component) _symbol_c.value;
					 return new SoftwareModel(new List<>(), new List<>(c), new List<>());
			}
			case 33: // software_model = property.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Property p = (Property) _symbol_p.value;
					 return new SoftwareModel(new List<>(), new List<>(), new List<>(p));
			}
			case 34: // component = COMPONENT.COMPONENT name.n LB_CURLY.LB_CURLY component_body.r RB_CURLY.RB_CURLY
			{
					final Symbol COMPONENT = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Name n = (Name) _symbol_n.value;
					final Symbol LB_CURLY = _symbols[offset + 3];
					final Symbol _symbol_r = _symbols[offset + 4];
					final Component r = (Component) _symbol_r.value;
					final Symbol RB_CURLY = _symbols[offset + 5];
					 r.setName(n);
      mph.componentMap.put(n.getName(), r);
      return r;
			}
			case 35: // component_body = implementation.i component_body.b
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Implementation i = (Implementation) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Component b = (Component) _symbol_b.value;
					 insertZero(b.getImplementationList(), i); return b;
			}
			case 36: // component_body = property.p component_body.b
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Property p = (Property) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Component b = (Component) _symbol_b.value;
					 insertZero(b.getPropertyList(), p); return b;
			}
			case 37: // component_body = USING.USING PROPERTY.PROPERTY property_ref.r component_body.b
			{
					final Symbol USING = _symbols[offset + 1];
					final Symbol PROPERTY = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final PropertyRef r = (PropertyRef) _symbol_r.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Component b = (Component) _symbol_b.value;
					 insertZero(b.getPropertyRefList(), r); return b;
			}
			case 38: // component_body = implementation.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Implementation i = (Implementation) _symbol_i.value;
					 return new Component(null, new List<>(i), new List<>(), new List<>());
			}
			case 39: // component_body = property.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Property p = (Property) _symbol_p.value;
					 return new Component(null, new List<>(), new List<>(p), new List<>());
			}
			case 40: // component_body = USING.USING PROPERTY.PROPERTY property_ref.r
			{
					final Symbol USING = _symbols[offset + 1];
					final Symbol PROPERTY = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final PropertyRef r = (PropertyRef) _symbol_r.value;
					 return new Component(null, new List<>(), new List<>(), new List<>(r));
			}
			case 41: // component_ref = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					 ComponentRef ref = new ComponentRef(n, null); mph.componentRefList.add(ref); return ref;
			}
			case 42: // hardware_model = resource_type.r hardware_model.m
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final ResourceType r = (ResourceType) _symbol_r.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final HardwareModel m = (HardwareModel) _symbol_m.value;
					 insertZero(m.getResourceTypeList(), r); return m;
			}
			case 43: // hardware_model = resource.s hardware_model.m
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Resource s = (Resource) _symbol_s.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final HardwareModel m = (HardwareModel) _symbol_m.value;
					 insertZero(m.getResourceList(), s); return m;
			}
			case 44: // hardware_model = property.p hardware_model.m
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Property p = (Property) _symbol_p.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final HardwareModel m = (HardwareModel) _symbol_m.value;
					 insertZero(m.getPropertyList(), p); return m;
			}
			case 45: // hardware_model = resource_type.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final ResourceType r = (ResourceType) _symbol_r.value;
					 return new HardwareModel(new List<>(r), new List<>(), new List<>());
			}
			case 46: // hardware_model = resource.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Resource s = (Resource) _symbol_s.value;
					 return new HardwareModel(new List<>(), new List<>(s), new List<>());
			}
			case 47: // hardware_model = property.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Property p = (Property) _symbol_p.value;
					 return new HardwareModel(new List<>(), new List<>(), new List<>(p));
			}
			case 48: // resource_type = RESOURCE.RESOURCE TYPE.TYPE name.n LB_CURLY.LB_CURLY resource_type_body_opt.opt RB_CURLY.RB_CURLY
			{
					final Symbol RESOURCE = _symbols[offset + 1];
					final Symbol TYPE = _symbols[offset + 2];
					final Symbol _symbol_n = _symbols[offset + 3];
					final Name n = (Name) _symbol_n.value;
					final Symbol LB_CURLY = _symbols[offset + 4];
					final Symbol _symbol_opt = _symbols[offset + 5];
					final Opt opt = (Opt) _symbol_opt.value;
					final Symbol RB_CURLY = _symbols[offset + 6];
					 ResourceType b;
      if (opt.getNumChild() > 0) {
        b = (ResourceType) opt.getChild(0);
      } else {
        b = new ResourceType(null, false, new List<>(), new List<>(), new List<>());
      }
      b.setName(n);
      b.setContainer(false);
      mph.resourceTypeMap.put(n.getName(), b);
      return b;
			}
			case 49: // resource_type = CONTAINER.CONTAINER RESOURCE.RESOURCE TYPE.TYPE name.n LB_CURLY.LB_CURLY resource_type_body_opt.opt RB_CURLY.RB_CURLY
			{
					final Symbol CONTAINER = _symbols[offset + 1];
					final Symbol RESOURCE = _symbols[offset + 2];
					final Symbol TYPE = _symbols[offset + 3];
					final Symbol _symbol_n = _symbols[offset + 4];
					final Name n = (Name) _symbol_n.value;
					final Symbol LB_CURLY = _symbols[offset + 5];
					final Symbol _symbol_opt = _symbols[offset + 6];
					final Opt opt = (Opt) _symbol_opt.value;
					final Symbol RB_CURLY = _symbols[offset + 7];
					 ResourceType b;
      if (opt.getNumChild() > 0) {
        b = (ResourceType) opt.getChild(0);
      } else {
        b = new ResourceType(null, false, new List<>(), new List<>(), new List<>());
      }
      b.setName(n);
      b.setContainer(true);
      mph.resourceTypeMap.put(n.getName(), b);
      return b;
			}
			case 50: // resource_type_body = resource_type.r resource_type_body.b
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final ResourceType r = (ResourceType) _symbol_r.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final ResourceType b = (ResourceType) _symbol_b.value;
					 insertZero(b.getSubTypeList(), r); return b;
			}
			case 51: // resource_type_body = property.p resource_type_body.b
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Property p = (Property) _symbol_p.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final ResourceType b = (ResourceType) _symbol_b.value;
					 insertZero(b.getPropertyList(), p); return b;
			}
			case 52: // resource_type_body = USING.USING PROPERTY.PROPERTY property_ref.pr resource_type_body.b
			{
					final Symbol USING = _symbols[offset + 1];
					final Symbol PROPERTY = _symbols[offset + 2];
					final Symbol _symbol_pr = _symbols[offset + 3];
					final PropertyRef pr = (PropertyRef) _symbol_pr.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final ResourceType b = (ResourceType) _symbol_b.value;
					 insertZero(b.getPropertyRefList(), pr); return b;
			}
			case 53: // resource_type_body = resource_type.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final ResourceType r = (ResourceType) _symbol_r.value;
					 return new ResourceType(null, false, new List<>(r), new List<>(), new List<>());
			}
			case 54: // resource_type_body = property.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Property p = (Property) _symbol_p.value;
					 return new ResourceType(null, false, new List<>(), new List<>(p), new List<>());
			}
			case 55: // resource_type_body = USING.USING PROPERTY.PROPERTY property_ref.pr
			{
					final Symbol USING = _symbols[offset + 1];
					final Symbol PROPERTY = _symbols[offset + 2];
					final Symbol _symbol_pr = _symbols[offset + 3];
					final PropertyRef pr = (PropertyRef) _symbol_pr.value;
					 return new ResourceType(null, false, new List<>(), new List<>(), new List<>(pr));
			}
			case 56: // resource_type_ref = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					 ResourceTypeRef ref = new ResourceTypeRef(n, null);
      mph.resourceTypeRefList.add(ref);
      return ref;
			}
			case 57: // resource = RESOURCE.RESOURCE name.n COLON.COLON resource_type_ref.r LB_CURLY.LB_CURLY RB_CURLY.RB_CURLY
			{
					final Symbol RESOURCE = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Name n = (Name) _symbol_n.value;
					final Symbol COLON = _symbols[offset + 3];
					final Symbol _symbol_r = _symbols[offset + 4];
					final ResourceTypeRef r = (ResourceTypeRef) _symbol_r.value;
					final Symbol LB_CURLY = _symbols[offset + 5];
					final Symbol RB_CURLY = _symbols[offset + 6];
					 return new Resource(n, r, new List<>(), new List<>());
			}
			case 58: // resource = RESOURCE.RESOURCE name.n COLON.COLON resource_type_ref.r LB_CURLY.LB_CURLY resource_body.b RB_CURLY.RB_CURLY
			{
					final Symbol RESOURCE = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Name n = (Name) _symbol_n.value;
					final Symbol COLON = _symbols[offset + 3];
					final Symbol _symbol_r = _symbols[offset + 4];
					final ResourceTypeRef r = (ResourceTypeRef) _symbol_r.value;
					final Symbol LB_CURLY = _symbols[offset + 5];
					final Symbol _symbol_b = _symbols[offset + 6];
					final Resource b = (Resource) _symbol_b.value;
					final Symbol RB_CURLY = _symbols[offset + 7];
					 b.setName(n);
      b.setType(r);
      return b;
			}
			case 59: // resource_body = resource.r resource_body.b
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final Resource r = (Resource) _symbol_r.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Resource b = (Resource) _symbol_b.value;
					 insertZero(b.getSubResourceList(), r); return b;
			}
			case 60: // resource_body = current_resource_value.v resource_body.b
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final CurrentResourceValue v = (CurrentResourceValue) _symbol_v.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Resource b = (Resource) _symbol_b.value;
					 insertZero(b.getCurrentResourceValueList(), v); return b;
			}
			case 61: // resource_body = resource.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final Resource r = (Resource) _symbol_r.value;
					 return new Resource(null, null, new List<>(r), new List<>());
			}
			case 62: // resource_body = current_resource_value.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final CurrentResourceValue v = (CurrentResourceValue) _symbol_v.value;
					 return new Resource(null, null, new List<>(), new List<>(v));
			}
			case 63: // current_resource_value = property_ref.r EQ.EQ literal_expression.l
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final PropertyRef r = (PropertyRef) _symbol_r.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final LiteralExpression l = (LiteralExpression) _symbol_l.value;
					 return new CurrentResourceValue(r,l);
			}
			case 64: // implementation = CONTRACT.CONTRACT name.n LB_CURLY.LB_CURLY implementation_body.b RB_CURLY.RB_CURLY
			{
					final Symbol CONTRACT = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Name n = (Name) _symbol_n.value;
					final Symbol LB_CURLY = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Implementation b = (Implementation) _symbol_b.value;
					final Symbol RB_CURLY = _symbols[offset + 5];
					 b.setName(n); return b;
			}
			case 65: // instance = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					 return new Instance(n);
			}
			case 66: // instance_list = instance.i COMMA.COMMA instance_list.l
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Instance i = (Instance) _symbol_i.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 insertZero(l, i);
			}
			case 67: // instance_list = instance.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Instance i = (Instance) _symbol_i.value;
					 return new List<>(i);
			}
			case 68: // component_requirement = REQUIRES.REQUIRES COMPONENT.COMPONENT instance_list.l OFTYPE.OFTYPE component_ref.cr
			{
					final Symbol REQUIRES = _symbols[offset + 1];
					final Symbol COMPONENT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol OFTYPE = _symbols[offset + 4];
					final Symbol _symbol_cr = _symbols[offset + 5];
					final ComponentRef cr = (ComponentRef) _symbol_cr.value;
					 return new ComponentRequirement(cr, l);
			}
			case 69: // resource_requirement = REQUIRES.REQUIRES RESOURCE.RESOURCE instance_list.l OFTYPE.OFTYPE resource_type_ref.rr WITH.WITH LB_CURLY.LB_CURLY inner_resource_requirement_opt_list.irr RB_CURLY.RB_CURLY
			{
					final Symbol REQUIRES = _symbols[offset + 1];
					final Symbol RESOURCE = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol OFTYPE = _symbols[offset + 4];
					final Symbol _symbol_rr = _symbols[offset + 5];
					final ResourceTypeRef rr = (ResourceTypeRef) _symbol_rr.value;
					final Symbol WITH = _symbols[offset + 6];
					final Symbol LB_CURLY = _symbols[offset + 7];
					final Symbol _symbol_irr = _symbols[offset + 8];
					final List irr = (List) _symbol_irr.value;
					final Symbol RB_CURLY = _symbols[offset + 9];
					 return new ResourceRequirement(rr, l, irr);
			}
			case 70: // resource_requirement = REQUIRES.REQUIRES RESOURCE.RESOURCE instance_list.l OFTYPE.OFTYPE resource_type_ref.rr
			{
					final Symbol REQUIRES = _symbols[offset + 1];
					final Symbol RESOURCE = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol OFTYPE = _symbols[offset + 4];
					final Symbol _symbol_rr = _symbols[offset + 5];
					final ResourceTypeRef rr = (ResourceTypeRef) _symbol_rr.value;
					 return new ResourceRequirement(rr, l, new List<>());
			}
			case 71: // inner_resource_requirement = instance_list.l OFTYPE.OFTYPE resource_type_ref.rr WITH.WITH LB_CURLY.LB_CURLY inner_resource_requirement_opt_list.irr RB_CURLY.RB_CURLY
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol OFTYPE = _symbols[offset + 2];
					final Symbol _symbol_rr = _symbols[offset + 3];
					final ResourceTypeRef rr = (ResourceTypeRef) _symbol_rr.value;
					final Symbol WITH = _symbols[offset + 4];
					final Symbol LB_CURLY = _symbols[offset + 5];
					final Symbol _symbol_irr = _symbols[offset + 6];
					final List irr = (List) _symbol_irr.value;
					final Symbol RB_CURLY = _symbols[offset + 7];
					 return new ResourceRequirement(rr, l, irr);
			}
			case 72: // inner_resource_requirement = instance_list.l OFTYPE.OFTYPE resource_type_ref.rr
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol OFTYPE = _symbols[offset + 2];
					final Symbol _symbol_rr = _symbols[offset + 3];
					final ResourceTypeRef rr = (ResourceTypeRef) _symbol_rr.value;
					 return new ResourceRequirement(rr, l, new List<>());
			}
			case 73: // designator = qualified_name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final QualifiedName n = (QualifiedName) _symbol_n.value;
					 return new QualifiedNameDesignator(n);
			}
			case 74: // clause = REQUIRING.REQUIRING designator.d LT.LT expression.e
			{
					final Symbol REQUIRING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.REQUIRING, d, ClauseComparator.LT, e);
			}
			case 75: // clause = REQUIRING.REQUIRING designator.d LE.LE expression.e
			{
					final Symbol REQUIRING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol LE = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.REQUIRING, d, ClauseComparator.LE, e);
			}
			case 76: // clause = REQUIRING.REQUIRING designator.d EQ.EQ expression.e
			{
					final Symbol REQUIRING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol EQ = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.REQUIRING, d, ClauseComparator.EQ, e);
			}
			case 77: // clause = REQUIRING.REQUIRING designator.d NE.NE expression.e
			{
					final Symbol REQUIRING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol NE = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.REQUIRING, d, ClauseComparator.NE, e);
			}
			case 78: // clause = REQUIRING.REQUIRING designator.d GE.GE expression.e
			{
					final Symbol REQUIRING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol GE = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.REQUIRING, d, ClauseComparator.GE, e);
			}
			case 79: // clause = REQUIRING.REQUIRING designator.d GT.GT expression.e
			{
					final Symbol REQUIRING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol GT = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.REQUIRING, d, ClauseComparator.GT, e);
			}
			case 80: // clause = PROVIDING.PROVIDING designator.d LT.LT expression.e
			{
					final Symbol PROVIDING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.PROVIDING, d, ClauseComparator.LT, e);
			}
			case 81: // clause = PROVIDING.PROVIDING designator.d LE.LE expression.e
			{
					final Symbol PROVIDING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol LE = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.PROVIDING, d, ClauseComparator.LE, e);
			}
			case 82: // clause = PROVIDING.PROVIDING designator.d EQ.EQ expression.e
			{
					final Symbol PROVIDING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol EQ = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.PROVIDING, d, ClauseComparator.EQ, e);
			}
			case 83: // clause = PROVIDING.PROVIDING designator.d NE.NE expression.e
			{
					final Symbol PROVIDING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol NE = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.PROVIDING, d, ClauseComparator.NE, e);
			}
			case 84: // clause = PROVIDING.PROVIDING designator.d GE.GE expression.e
			{
					final Symbol PROVIDING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol GE = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.PROVIDING, d, ClauseComparator.GE, e);
			}
			case 85: // clause = PROVIDING.PROVIDING designator.d GT.GT expression.e
			{
					final Symbol PROVIDING = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final Designator d = (Designator) _symbol_d.value;
					final Symbol GT = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Clause(ClauseType.PROVIDING, d, ClauseComparator.GT, e);
			}
			case 86: // implementation_body = component_requirement.cr implementation_body.b
			{
					final Symbol _symbol_cr = _symbols[offset + 1];
					final ComponentRequirement cr = (ComponentRequirement) _symbol_cr.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Implementation b = (Implementation) _symbol_b.value;
					 insertZero(b.getComponentRequirementList(), cr); return b;
			}
			case 87: // implementation_body = resource_requirement.rr implementation_body.b
			{
					final Symbol _symbol_rr = _symbols[offset + 1];
					final ResourceRequirement rr = (ResourceRequirement) _symbol_rr.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Implementation b = (Implementation) _symbol_b.value;
					 b.setResourceRequirement(rr); return b;
			}
			case 88: // implementation_body = clause.c implementation_body.b
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Clause c = (Clause) _symbol_c.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Implementation b = (Implementation) _symbol_b.value;
					 insertZero(b.getClauseList(), c); return b;
			}
			case 89: // implementation_body = component_requirement.cr
			{
					final Symbol _symbol_cr = _symbols[offset + 1];
					final ComponentRequirement cr = (ComponentRequirement) _symbol_cr.value;
					 return new Implementation(null, new List<>(cr), null, new List<>());
			}
			case 90: // implementation_body = resource_requirement.rr
			{
					final Symbol _symbol_rr = _symbols[offset + 1];
					final ResourceRequirement rr = (ResourceRequirement) _symbol_rr.value;
					 return new Implementation(null, new List<>(), rr, new List<>());
			}
			case 91: // implementation_body = clause.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Clause c = (Clause) _symbol_c.value;
					 return new Implementation(null, new List<>(), null, new List<>(c));
			}
			case 92: // solution = SOLUTION.SOLUTION LB_CURLY.LB_CURLY assignment_opt_list.al RB_CURLY.RB_CURLY
			{
					final Symbol SOLUTION = _symbols[offset + 1];
					final Symbol LB_CURLY = _symbols[offset + 2];
					final Symbol _symbol_al = _symbols[offset + 3];
					final List al = (List) _symbol_al.value;
					final Symbol RB_CURLY = _symbols[offset + 4];
					 mph.unfinishedSolution = new Solution(null, al);
      return mph.unfinishedSolution;
			}
			case 93: // assignment = NAME.i RIGHT_ARROW.RIGHT_ARROW NAME.impl LB_CURLY.LB_CURLY resource_mapping.rm RB_CURLY.RB_CURLY
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol RIGHT_ARROW = _symbols[offset + 2];
					final Symbol impl = _symbols[offset + 3];
					final Symbol LB_CURLY = _symbols[offset + 4];
					final Symbol _symbol_rm = _symbols[offset + 5];
					final ResourceMapping rm = (ResourceMapping) _symbol_rm.value;
					final Symbol RB_CURLY = _symbols[offset + 6];
					 Assignment result = new Assignment(true, null, null, rm, new List());
      mph.assignmentTerminals.put(result, new Tuple<>(((String)i.value), ((String)impl.value)));
      return result;
			}
			case 94: // assignment = NAME.i RIGHT_ARROW.RIGHT_ARROW NAME.impl LB_CURLY.LB_CURLY resource_mapping.rm component_mapping_list.cml RB_CURLY.RB_CURLY
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol RIGHT_ARROW = _symbols[offset + 2];
					final Symbol impl = _symbols[offset + 3];
					final Symbol LB_CURLY = _symbols[offset + 4];
					final Symbol _symbol_rm = _symbols[offset + 5];
					final ResourceMapping rm = (ResourceMapping) _symbol_rm.value;
					final Symbol _symbol_cml = _symbols[offset + 6];
					final List cml = (List) _symbol_cml.value;
					final Symbol RB_CURLY = _symbols[offset + 7];
					 Assignment result = new Assignment(true, null, null, rm, cml);
      mph.assignmentTerminals.put(result, new Tuple<>(((String)i.value), ((String)impl.value)));
      return result;
			}
			case 95: // resource_mapping = NAME.i RIGHT_ARROW.RIGHT_ARROW NAME.res
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol RIGHT_ARROW = _symbols[offset + 2];
					final Symbol res = _symbols[offset + 3];
					 ResourceMapping result = new ResourceMapping();
      mph.resourceMappingTerminals.put(result, new Tuple<>(((String)i.value), ((String)res.value)));
      return result;
			}
			case 96: // resource_mapping = NAME.i RIGHT_ARROW.RIGHT_ARROW NAME.res LB_CURLY.LB_CURLY resource_mapping_opt_list.rml RB_CURLY.RB_CURLY
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol RIGHT_ARROW = _symbols[offset + 2];
					final Symbol res = _symbols[offset + 3];
					final Symbol LB_CURLY = _symbols[offset + 4];
					final Symbol _symbol_rml = _symbols[offset + 5];
					final List rml = (List) _symbol_rml.value;
					final Symbol RB_CURLY = _symbols[offset + 6];
					 ResourceMapping result = new ResourceMapping(null, null, rml);
      mph.resourceMappingTerminals.put(result, new Tuple<>(((String)i.value), ((String)res.value)));
      return result;
			}
			case 97: // component_mapping = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Assignment a = (Assignment) _symbol_a.value;
					 a.setTopLevel(false);
      ComponentMapping result = new ComponentMapping(null, a);
      return result;
			}
			case 98: // request_list = request.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Request n = (Request) _symbol_n.value;
					 return new List().add(n);
			}
			case 99: // request_list = request_list.l request.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final Request n = (Request) _symbol_n.value;
					 return l.add(n);
			}
			case 100: // inner_resource_requirement_opt_list = 
			{
					 return new List();
			}
			case 101: // inner_resource_requirement_opt_list = inner_resource_requirement_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 102: // inner_resource_requirement_list = inner_resource_requirement.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ResourceRequirement n = (ResourceRequirement) _symbol_n.value;
					 return new List().add(n);
			}
			case 103: // inner_resource_requirement_list = inner_resource_requirement_list.l inner_resource_requirement.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final ResourceRequirement n = (ResourceRequirement) _symbol_n.value;
					 return l.add(n);
			}
			case 104: // component_mapping_list = component_mapping.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ComponentMapping n = (ComponentMapping) _symbol_n.value;
					 return new List().add(n);
			}
			case 105: // component_mapping_list = component_mapping_list.l component_mapping.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final ComponentMapping n = (ComponentMapping) _symbol_n.value;
					 return l.add(n);
			}
			case 106: // resource_type_body_opt = 
			{
					 return new Opt();
			}
			case 107: // resource_type_body_opt = resource_type_body.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ResourceType n = (ResourceType) _symbol_n.value;
					 return new Opt(n);
			}
			case 108: // assignment_opt_list = 
			{
					 return new List();
			}
			case 109: // assignment_opt_list = assignment_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 110: // assignment_list = assignment.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Assignment n = (Assignment) _symbol_n.value;
					 return new List().add(n);
			}
			case 111: // assignment_list = assignment_list.l assignment.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final Assignment n = (Assignment) _symbol_n.value;
					 return l.add(n);
			}
			case 112: // resource_mapping_opt_list = 
			{
					 return new List();
			}
			case 113: // resource_mapping_opt_list = resource_mapping_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 114: // resource_mapping_list = resource_mapping.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ResourceMapping n = (ResourceMapping) _symbol_n.value;
					 return new List().add(n);
			}
			case 115: // resource_mapping_list = resource_mapping_list.l resource_mapping.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final ResourceMapping n = (ResourceMapping) _symbol_n.value;
					 return l.add(n);
			}
			case 0: // $goal = goal
			{
				return _symbols[offset + 1];
			}
			case 1: // $goal = $solution solution
			{
				return _symbols[offset + 2];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
